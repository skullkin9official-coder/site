<!DOCTYPE html>
<html lang="en-US">
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/otplib/12.0.1/otplib-browser.js"></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3RROR5TUDIOS — Errorverse (2FA PlayFab)</title>
  <link rel="icon" type="image/png" href="images/3RROR5TUDIOS.png">
  <style>
/* ---------- styles (kept/cleaned) ---------- */
*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:Arial,Helvetica,sans-serif;
  background:linear-gradient(135deg,#40006e,#8100b4);
  color:#fff;
  min-height:100vh;
  padding-top:120px; /* space for rounded topbar */
}

/* rounded topbar */
.clean-topbar{
  position:fixed;top:15px;left:50%;transform:translateX(-50%);
  width:92%;height:60px;background:rgba(0,0,0,0.25);
  border-radius:18px;backdrop-filter:blur(12px);padding:0 25px;
  display:flex;justify-content:space-between;align-items:center;z-index:9999;
}
.tb-left{display:flex;align-items:center;gap:18px}
.tb-logo{height:36px}
.tb-title{font-size:20px;font-weight:700;color:#fff;margin-right:10px}
.tb-link{color:#fff;text-decoration:none;font-size:16px;padding:6px 10px;border-radius:8px;transition:.15s}
.tb-link:hover{background:rgba(255,255,255,0.06)}
.tb-right{display:flex;align-items:center;gap:10px}
.tb-pfp{width:34px;height:34px;border-radius:50%;border:2px solid #ffdd00;object-fit:cover}

/* cards */
.card{
  background:rgba(0,0,0,0.4);padding:20px;border-radius:12px;max-width:600px;margin:30px auto;box-shadow:0 6px 18px rgba(0,0,0,.35)
}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:20px}
.tile{background:rgba(255,255,255,0.08);padding:10px;text-align:center;border-radius:10px}
.tile img{width:100%;border-radius:10px}
#profileCustomizer img{width:64px;height:64px;border-radius:50%;Display:block;margin:8px auto;object-fit:cover}

/* dropdown */
#profileDropdown{position:fixed;top:90px;right:calc((100% - 92%)/2 + 25px);width:220px;background:rgba(0,0,0,0.65);border-radius:10px;padding:10px;display:none;z-index:10000;animation:dropdownFade .12s ease-out}
#profileDropdown button{width:100%;background:#c300ff;border:none;padding:8px;border-radius:8px;color:#fff;margin-bottom:8px;cursor:pointer}
@keyframes dropdownFade{from{opacity:0;transform:translateY(-6px)}to{opacity:1;transform:translateY(0)}}

/* small forms */
input[type="text"],input[type="password"],input[type="email"]{width:100%;padding:10px;border-radius:8px;border:none;margin-top:8px;background:#fff;background-clip:padding-box;color:#000}
textarea{width:100%;padding:10px;border-radius:8px;border:none;margin-top:8px}
button.primary{background:#c300ff;border:none;color:#fff;padding:10px;border-radius:8px;cursor:pointer;font-weight:700}
button.secondary{background:#6a00d6;border:none;color:#fff;padding:8px;border-radius:8px;cursor:pointer}

/* helper */
.hidden{display:none!important}
small.note{color:#ffd400;font-size:13px;display:block;margin-top:8px}

/* responsive */
@media(max-width:600px){
  .clean-topbar{width:96%;padding:0 12px}
  #profileDropdown{right:8px;top:85px}
}
  </style>
</head>
<body>

<!-- ========== TOP BAR (rounded) ========== -->
<div class="clean-topbar">
  <div class="tb-left">
    <a href="index.html" class="tb-link">
    <img src="images/3RROR5TUDIOS.png" class="tb-logo" alt="logo">
</a>
    <span class="tb-title">3RROR5TUDIOS</span>
    <a href="Games.html" class="tb-link">Games</a>
    <a href="ERRORVERSE.html" class="tb-link">Errorverse</a>
  </div>

  <div class="tb-right" id="profileButton" role="button" aria-haspopup="true">
    <img id="profileAvatar" src="images/default_avatar.png" class="tb-pfp" alt="avatar">
    <span id="profileName">User</span>
  </div>
</div>

<!-- dropdown -->
<div id="profileDropdown" aria-hidden="true">
  <button id="openCustomizer">Customize Profile</button>
  <button id="logoutBtn">Logout</button>
</div>

<!-- ========== LOGIN (keeps visible) ========== -->
<div class="card" id="loginCard">
  <h2>Login / Register</h2>

  <label>Email</label>
  <input id="email" type="email" placeholder="you@example.com">

  <label style="margin-top:10px">Password</label>
  <input id="password" type="password" placeholder="min 6 chars">

  <div style="display:flex;gap:10px;margin-top:12px;">
    <button id="loginBtnMain" class="primary" style="flex:1">Login</button>
    <button id="registerBtn" class="secondary" style="flex:1">Register</button>
  </div>

  <p id="status" class="note"></p>

  <!-- 2FA: shown only when needed -->
  <div id="twofaBox" style="margin-top:12px;display:none;">
    <label>Enter 2FA code</label>
    <input id="twofaInput" type="text" placeholder="6-digit code">
    <div style="display:flex;gap:8px;margin-top:8px;">
      <button id="verify2faBtn" class="primary" style="flex:1">Verify</button>
      <button id="cancel2faBtn" class="secondary" style="flex:1">Cancel</button>
    </div>
    <small class="note">Using Google Authenticator (TOTP)</small>
  </div>
</div>

<!-- ========== PROFILE CUSTOMIZER (keeps visible, now includes 2FA setup) ========== -->
<div id="profileCustomizer" class="card">
  <h3 style="color:#ffd400">Customize Profile</h3>
  <img id="customAvatar" src="images/default_avatar.png" alt="avatar">

  <label>Username:</label>
  <input type="text" id="customUsername" placeholder="Enter username">

  <label style="margin-top:10px">Avatar URL:</label>
  <input type="text" id="customAvatarURL" placeholder="https://...">

  <div style="display:flex;gap:10px;margin-top:12px;">
    <button id="saveProfile" class="primary" style="flex:1">Save Changes</button>
    <button id="savePlayfabBtn" class="secondary" style="flex:1">Save to PlayFab</button>
  </div>

  <hr style="border:none;height:10px">

  <!-- TOTP setup -->
  <h4 style="margin-top:6px">Two-Factor Authentication (Google Authenticator)</h4>
  <div id="totpSetup">
    <div style="display:flex;gap:10px;margin-top:8px;">
      <button id="enable2faBtn" class="primary" style="flex:1">Enable 2FA</button>
      <button id="disable2faBtn" class="secondary" style="flex:1">Disable 2FA</button>
    </div>

    <div id="setupArea" style="margin-top:12px;display:none;">
      <p style="font-size:13px">Scan this QR in Google Authenticator or copy the secret below.</p>
      <img id="qrImg" src="" alt="qr" style="display:block;margin:10px auto;max-width:180px;background:#fff;padding:6px;border-radius:6px">
      <div style="display:flex;gap:8px;align-items:center;">
        <input id="secretText" type="text" readonly style="flex:1;padding:8px;border-radius:6px;border:none;background:#fff;color:#000">
        <button id="copySecret" class="secondary">Copy</button>
      </div>

      <label style="margin-top:8px">Enter code to confirm</label>
      <input id="confirm2faCode" type="text" placeholder="6-digit code">
      <div style="display:flex;gap:8px;margin-top:8px;">
        <button id="confirm2faBtn" class="primary" style="flex:1">Confirm</button>
        <button id="hideSetup" class="secondary" style="flex:1">Cancel</button>
      </div>
    </div>
    <small id="totpNote" class="note">2FA status: <span id="totpStatus">Disabled</span></small>
  </div>
</div>

<!-- ========== INVENTORY ========== -->
<div class="card" id="inventoryCard" style="display:none">
  <h2>Your Inventory</h2>
  <button id="refreshInv" class="secondary" style="margin-top:8px">Refresh Inventory</button>
  <div class="grid" id="inventoryGrid" style="margin-top:12px"></div>
</div>

<!-- ========== JS section: PlayFab + TOTP (PlayFab-backed 2FA) ========== -->
<script>
/* ============================
   PlayFab client wrapper (kept + additions)
   ============================ */
var PlayFab={settings:{titleId:"1FC26D"},_internalSettings:{sessionTicket:null}};

var PlayFabClientAPI={
  LoginWithEmailAddress:(req,success,error)=>{
    req.TitleId=PlayFab.settings.titleId;
    fetch("https://1FC26D.playfabapi.com/Client/LoginWithEmailAddress",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(req)})
    .then(r=>r.json()).then(x=>x.data?success(x):error(x)).catch(e=>error(e));
  },
  RegisterPlayFabUser:(req,success,error)=>{
    req.TitleId=PlayFab.settings.titleId;
    fetch("https://1FC26D.playfabapi.com/Client/RegisterPlayFabUser",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(req)})
    .then(r=>r.json()).then(x=>x.data?success(x):error(x)).catch(e=>error(e));
  },
  GetUserInventory:(req,success,error)=>{
    fetch("https://1FC26D.playfabapi.com/Client/GetUserInventory",{method:"POST",headers:{"Content-Type":"application/json","X-Authorization":PlayFab._internalSettings.sessionTicket},body:"{}"})
    .then(r=>r.json()).then(x=>x.data?success(x):error(x)).catch(e=>error(e));
  },
  // Client UpdateUserData and UpdateUserTitleDisplayName
  UpdateUserData:(req,success,error)=>{
    fetch("https://1FC26D.playfabapi.com/Client/UpdateUserData",{method:"POST",headers:{"Content-Type":"application/json","X-Authorization":PlayFab._internalSettings.sessionTicket},body:JSON.stringify(req)})
    .then(r=>r.json()).then(x=>x.data?success(x):error(x)).catch(e=>error(e));
  },
  UpdateUserTitleDisplayName:(req,success,error)=>{
    fetch("https://1FC26D.playfabapi.com/Client/UpdateUserTitleDisplayName",{method:"POST",headers:{"Content-Type":"application/json","X-Authorization":PlayFab._internalSettings.sessionTicket},body:JSON.stringify(req)})
    .then(r=>r.json()).then(x=>x.data?success(x):error(x)).catch(e=>error(e));
  },
  // NEW: GetUserData (to read avatarUrl and other keys)
  GetUserData:(req,success,error)=>{
    // req can be {} or {Keys: ["avatarUrl"]}
    fetch("https://1FC26D.playfabapi.com/Client/GetUserData",{method:"POST",headers:{"Content-Type":"application/json","X-Authorization":PlayFab._internalSettings.sessionTicket},body:JSON.stringify(req||{})})
    .then(r=>r.json()).then(x=>x.data?success(x):error(x)).catch(e=>error(e));
  },
  // NEW (optional): GetPlayerProfile to try and get DisplayName from server
  GetPlayerProfile:(req,success,error)=>{
    fetch("https://1FC26D.playfabapi.com/Client/GetPlayerProfile",{method:"POST",headers:{"Content-Type":"application/json","X-Authorization":PlayFab._internalSettings.sessionTicket},body:JSON.stringify(req||{})})
    .then(r=>r.json()).then(x=>x.data?success(x):error(x)).catch(e=>error(e));
  }
};

/* ============================
   Helpers & element refs
   ============================ */
const profileButton = document.getElementById("profileButton");
const profileDropdown = document.getElementById("profileDropdown");
const navbarName = document.getElementById("profileName");
const navbarPFP = document.getElementById("profileAvatar");
const openCustomizer = document.getElementById("openCustomizer");
const logoutBtn = document.getElementById("logoutBtn");

const emailEl = document.getElementById("email");
const passwordEl = document.getElementById("password");
const statusEl = document.getElementById("status");
const loginBtn = document.getElementById("loginBtnMain");
const registerBtn = document.getElementById("registerBtn");
const loginCard = document.getElementById("loginCard");
const inventoryCard = document.getElementById("inventoryCard");
const inventoryGrid = document.getElementById("inventoryGrid");
const refreshBtn = document.getElementById("refreshInv");

const profileCustomizer = document.getElementById("profileCustomizer");
const customUsername = document.getElementById("customUsername");
const customAvatar = document.getElementById("customAvatar");
const customAvatarURL = document.getElementById("customAvatarURL");
const saveProfile = document.getElementById("saveProfile");
const savePlayfabBtn = document.getElementById("savePlayfabBtn");

const enable2faBtn = document.getElementById("enable2faBtn");
const disable2faBtn = document.getElementById("disable2faBtn");
const setupArea = document.getElementById("setupArea");
const qrImg = document.getElementById("qrImg");
const secretText = document.getElementById("secretText");
const confirm2faCode = document.getElementById("confirm2faCode");
const confirm2faBtn = document.getElementById("confirm2faBtn");
const hideSetup = document.getElementById("hideSetup");
const totpStatus = document.getElementById("totpStatus");
const copySecret = document.getElementById("copySecret");

const twofaBox = document.getElementById("twofaBox");
const twofaInput = document.getElementById("twofaInput");
const verify2faBtn = document.getElementById("verify2faBtn");
const cancel2faBtn = document.getElementById("cancel2faBtn");

/* ============================
   TOTP implementation (RFC6238)
   - base32 decode
   - HMAC-SHA1 using WebCrypto
   - generateTOTP
   ============================ */

/* Base32 decode (RFC4648) */
function base32toHex(base32){
  base32 = base32.replace(/=+$/,'').toUpperCase();
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  let bits = "";
  for(let i=0;i<base32.length;i++){
    const val = alphabet.indexOf(base32.charAt(i));
    if(val===-1) continue;
    bits += val.toString(2).padStart(5,'0');
  }
  // convert bits to hex
  let hex = "";
  for(let i=0;i+8<=bits.length;i+=8){
    hex += parseInt(bits.substr(i,8),2).toString(16).padStart(2,'0');
  }
  return hex;
}

/* convert hex to ArrayBuffer */
function hexToArrayBuffer(hex){
  if(hex.length%2) hex='0'+hex;
  const len = hex.length/2;
  const ab = new Uint8Array(len);
  for(let i=0;i<len;i++) ab[i]=parseInt(hex.substr(i*2,2),16);
  return ab.buffer;
}

/* HMAC-SHA1 using WebCrypto, input key ArrayBuffer, message ArrayBuffer */
async function hmacSha1(keyBuf, messageBuf){
  const key = await crypto.subtle.importKey("raw", keyBuf, {name:"HMAC",hash:{name:"SHA-1"}}, false, ["sign"]);
  const sig = await crypto.subtle.sign("HMAC", key, messageBuf);
  return new Uint8Array(sig);
}

/* Generate TOTP
   secretBase32: base32 secret string
   timeStep: seconds (default 30)
   digits: code digits (default 6)
*/
async function generateTOTP(secretBase32, timeStep=30, digits=6){
  const keyHex = base32toHex(secretBase32);
  const keyBuf = hexToArrayBuffer(keyHex);
  const epoch = Math.floor(Date.now()/1000);
  const counter = Math.floor(epoch/timeStep);
  // 8-byte counter big-endian
  const counterBuf = new ArrayBuffer(8);
  const dv = new DataView(counterBuf);
  // set high/low 32 bits
  const high = Math.floor(counter/0x100000000);
  const low = counter & 0xffffffff;
  dv.setUint32(0, high);
  dv.setUint32(4, low);
  const hmac = await hmacSha1(keyBuf, counterBuf);
  // dynamic truncation
  const offset = hmac[hmac.length-1] & 0x0f;
  const code = ((hmac[offset]&0x7f)<<24) | ((hmac[offset+1]&0xff)<<16) | ((hmac[offset+2]&0xff)<<8) | (hmac[offset+3]&0xff);
  const otp = (code % (10**digits)).toString().padStart(digits,'0');
  return otp;
}

/* Verify TOTP allowing window +-1 (30s) */
async function verifyTOTP(secretBase32, code, timeStep=30, digits=6){
  if(!secretBase32 || !code) return false;
  code = String(code).trim();
  // check +/-1 window
  for(let i=-1;i<=1;i++){
    const epoch = Math.floor((Date.now()/1000 + i*timeStep)/timeStep);
    // generate with offset by changing counter inside generate function by mocking Date (easier to implement directly)
    // We'll implement a helper that accepts counter override:
    const otp = await generateTOTPWithCounter(secretBase32, epoch, digits);
    if(otp === code) return true;
  }
  return false;
}

async function generateTOTPWithCounter(secretBase32, counter, digits=6){
  const keyHex = base32toHex(secretBase32);
  const keyBuf = hexToArrayBuffer(keyHex);
  const counterBuf = new ArrayBuffer(8);
  const dv = new DataView(counterBuf);
  const high = Math.floor(counter/0x100000000);
  const low = counter & 0xffffffff;
  dv.setUint32(0, high);
  dv.setUint32(4, low);
  const hmac = await hmacSha1(keyBuf, counterBuf);
  const offset = hmac[hmac.length-1] & 0x0f;
  const code = ((hmac[offset]&0x7f)<<24) | ((hmac[offset+1]&0xff)<<16) | ((hmac[offset+2]&0xff)<<8) | (hmac[offset+3]&0xff);
  const otp = (code % (10**digits)).toString().padStart(digits,'0');
  return otp;
}

/* Generate random Base32 secret */
function generateBase32Secret(length=16){
  const alphabet="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  let s="";
  const arr = new Uint8Array(length);
  crypto.getRandomValues(arr);
  for(let i=0;i<length;i++){
    s += alphabet[arr[i] % alphabet.length];
  }
  return s;
}

/* Build otpauth URL */
function buildOtpAuthURL(account, issuer, secret){
  // label must be URL-encoded
  const label = encodeURIComponent(`${issuer}:${account}`);
  const params = `secret=${secret}&issuer=${encodeURIComponent(issuer)}&algorithm=SHA1&digits=6&period=30`;
  return `otpauth://totp/${label}?${params}`;
}

/* Generate QR image URL using Google Charts */
function generateQRImageUrl(data, size=200){
  return "https://chart.googleapis.com/chart?cht=qr&chs=" + size + "x" + size + "&chl=" + encodeURIComponent(data);
}

/* ============================
   TOTP: setup/enable/disable flow (PlayFab-backed)
   ============================ */

/* Enable 2FA: generate secret and show QR (temporary) */
enable2faBtn.addEventListener("click", async ()=>{
  // ensure user is logged in
  const pfid = localStorage.getItem("PLAYFAB_PLAYFABID");
  const ticket = localStorage.getItem("PLAYFAB_SESSIONTICKET");
  if(!pfid || !ticket){ alert("You must be logged in to enable 2FA"); return; }

  // generate secret
  const secret = generateBase32Secret(20);
  // store temporary in session (don't commit until confirmed)
  sessionStorage.setItem("TOTP_PENDING_SECRET", secret);
  // build otpauth
  const labelAccount = (document.getElementById("customUsername").value.trim() || pfid);
  const otpauth = buildOtpAuthURL(labelAccount, "Errorverse", secret);
  const qr = generateQRImageUrl(otpauth, 200);
  qrImg.src = qr;
  secretText.value = secret;
  setupArea.style.display = "block";
});

/* Confirm 2FA (user enters code from authenticator) -> commit to PlayFab */
confirm2faBtn.addEventListener("click", async ()=>{
  const entered = confirm2faCode.value.trim();
  const secret = sessionStorage.getItem("TOTP_PENDING_SECRET");
  const pfid = localStorage.getItem("PLAYFAB_PLAYFABID");
  const ticket = localStorage.getItem("PLAYFAB_SESSIONTICKET");
  if(!pfid || !ticket){ alert("You must be logged in to enable 2FA"); return; }
  if(!secret){ alert("No pending secret. Click Enable 2FA first."); return; }

  const ok = await verifyTOTP(secret, entered);
  if(!ok){ alert("Invalid code. Try again."); return; }

  // commit to PlayFab: set two_factor_enabled=true and two_factor_secret=secret
  PlayFab._internalSettings.sessionTicket = ticket;
  PlayFabClientAPI.UpdateUserData({Data:{two_factor_enabled: "true", two_factor_secret: secret}}, (res)=>{
    sessionStorage.removeItem("TOTP_PENDING_SECRET");
    setupArea.style.display = "none";
    totpStatus.textContent = "Enabled";
    alert("2FA enabled and saved to PlayFab!");
  }, (err)=>{
    console.error(err);
    alert("Failed to save 2FA to PlayFab. See console.");
  });
});

/* Hide setup / cancel */
hideSetup.addEventListener("click", ()=>{
  sessionStorage.removeItem("TOTP_PENDING_SECRET");
  setupArea.style.display = "none";
});

/* Copy secret */
copySecret.addEventListener("click", ()=>{
  navigator.clipboard.writeText(secretText.value).then(()=>alert("Copied"));
});

/* Disable 2FA: clear PlayFab keys (mark disabled and clear secret) */
disable2faBtn.addEventListener("click", ()=>{
  const pfid = localStorage.getItem("PLAYFAB_PLAYFABID");
  const ticket = localStorage.getItem("PLAYFAB_SESSIONTICKET");
  if(!pfid || !ticket){ alert("You must be logged in to disable 2FA"); return; }
  PlayFab._internalSettings.sessionTicket = ticket;
  PlayFabClientAPI.UpdateUserData({Data:{two_factor_enabled: "false", two_factor_secret: ""}}, (res)=>{
    totpStatus.textContent = "Disabled";
    alert("2FA disabled for this account (PlayFab updated).");
  }, (err)=>{
    console.error(err);
    alert("Failed to disable 2FA. See console.");
  });
});

/* Update TOTP UI status by querying PlayFab (if logged in) */
function refreshTOTPStatus(){
  const pfid = localStorage.getItem("PLAYFAB_PLAYFABID");
  const ticket = localStorage.getItem("PLAYFAB_SESSIONTICKET");
  if(!pfid || !ticket){ totpStatus.textContent = "Disabled"; return; }
  PlayFab._internalSettings.sessionTicket = ticket;
  PlayFabClientAPI.GetUserData({}, (res)=>{
    try{
      const data = res.data.Data || {};
      if(data.two_factor_enabled && data.two_factor_enabled.Value === "true") totpStatus.textContent = "Enabled";
      else totpStatus.textContent = "Disabled";
    }catch(e){ console.warn(e); totpStatus.textContent = "Disabled"; }
  }, (err)=>{ console.warn(err); totpStatus.textContent = "Disabled"; });
}

/* ============================
   Login flow modified to require TOTP if enabled (PlayFab-backed)
   - On PlayFab login success: set sessionTicket and query GetUserData()
     - If two_factor_enabled === "true" -> require OTP
     - Else finalize immediately
   ============================ */

function setStatus(msg,color="yellow"){ statusEl.style.color=color; statusEl.textContent=msg; }

/* Finalize session: save to localStorage, set ticket, update UI, and fetch server-stored profile (username+avatar) */
async function finalizeSessionAfter2FAVerified(res){
  const d = res.data;
  // store session
  localStorage.setItem("PLAYFAB_PLAYFABID", d.PlayFabId);
  localStorage.setItem("PLAYFAB_SESSIONTICKET", d.SessionTicket);
  PlayFab._internalSettings.sessionTicket = d.SessionTicket;

  // Update inventory UI
  inventoryCard.style.display = "block";
  setStatus("Logged in: " + d.PlayFabId, "#ffd400");
  fetchInventory();

  // Attempt to fetch display name from response's PlayerProfile (if present)
  try {
    const profile = d.InfoResultPayload && d.InfoResultPayload.PlayerProfile;
    if(profile && profile.DisplayName){
      localStorage.setItem("CUSTOM_USERNAME", profile.DisplayName);
      navbarName.textContent = profile.DisplayName;
      customUsername.value = profile.DisplayName;
    }
  } catch(e){ console.warn("No PlayerProfile in login response", e); }

  // Now fetch stored user data (avatarUrl) from PlayFab, and apply if present
  PlayFabClientAPI.GetUserData({}, (udRes)=>{
    try{
      const data = udRes.data.Data || {};
      if(data.avatarUrl && data.avatarUrl.Value){
        const avatarUrl = data.avatarUrl.Value;
        localStorage.setItem("CUSTOM_AVATAR", avatarUrl);
        navbarPFP.src = avatarUrl;
        customAvatar.src = avatarUrl;
        customAvatarURL.value = avatarUrl;
      } else {
        const localAvatar = localStorage.getItem("CUSTOM_AVATAR");
        if(localAvatar){ navbarPFP.src = localAvatar; }
      }
    } catch(e){ console.error("Error applying user data", e); }
  }, (err)=>{ console.warn("GetUserData failed:", err); });

  // hide 2FA UI if shown
  twofaBox.style.display = "none";
  twofaInput.value = "";
  // refresh TOTP status
  refreshTOTPStatus();
}

/* Called after PlayFab login response but before finalization */
async function handlePostPlayFabLogin(res){
  const d = res.data;
  const pfid = d.PlayFabId;
  const ticket = d.SessionTicket;
  // set session ticket temporarily so GetUserData works
  PlayFab._internalSettings.sessionTicket = ticket;

  // Query PlayFab for two_factor_enabled
  PlayFabClientAPI.GetUserData({}, (udRes)=>{
    try{
      const data = udRes.data.Data || {};
      const enabled = data.two_factor_enabled && data.two_factor_enabled.Value === "true";
      if(enabled){
        // require TOTP
        setStatus("2FA code required for " + pfid,"#ffd400");
        // show 2FA input UI and hold the login response in sessionStorage for later finalization
        sessionStorage.setItem("PLAYFAB_PENDING_LOGIN", JSON.stringify(res));
        twofaBox.style.display = "block";
        return;
      } else {
        // finalize directly
        finalizeSessionAfter2FAVerified(res);
      }
    }catch(e){
      console.warn("Error reading user data", e);
      finalizeSessionAfter2FAVerified(res);
    }
  }, (err)=>{
    // If GetUserData fails for some reason, proceed with login but warn
    console.warn("GetUserData failed after login:", err);
    finalizeSessionAfter2FAVerified(res);
  });
}

/* Login button: authenticate with PlayFab then handle 2FA */
loginBtn.addEventListener("click", ()=>{
  const email = emailEl.value.trim(), pw = passwordEl.value;
  if(!email || pw.length < 6){ setStatus("Enter valid email/password","red"); return; }
  setStatus("Logging in...");
  PlayFabClientAPI.LoginWithEmailAddress({Email:email,Password:pw},
    async (res)=>{
      try { await handlePostPlayFabLogin(res); } catch(e){ console.error(e); setStatus("Error during 2FA flow","red"); }
    },
    err => setStatus(err.errorMessage || JSON.stringify(err),"red")
  );
});

/* Register */
registerBtn.addEventListener("click", ()=>{
  const email = emailEl.value.trim(), pw = passwordEl.value;
  if(!email || pw.length < 6){ setStatus("Enter valid email/password","red"); return; }
  setStatus("Registering...");
  PlayFabClientAPI.RegisterPlayFabUser({Email:email,Password:pw,RequireBothUsernameAndEmail:false},
    async (res)=>{ try { await handlePostPlayFabLogin(res); } catch(e){ console.error(e); setStatus("Error during post-register 2FA","red"); } },
    err=>setStatus(err.errorMessage||JSON.stringify(err),"red")
  );
});

/* Verify 2FA during login */
verify2faBtn.addEventListener("click", async ()=>{
  const code = twofaInput.value.trim();
  const pending = sessionStorage.getItem("PLAYFAB_PENDING_LOGIN");
  if(!pending){ setStatus("No pending login found","red"); return; }
  const res = JSON.parse(pending);
  const pfid = res.data.PlayFabId;
  const ticket = res.data.SessionTicket;
  if(!ticket){ setStatus("Missing session ticket","red"); return; }

  // set ticket so we can read stored secret via GetUserData
  PlayFab._internalSettings.sessionTicket = ticket;
  PlayFabClientAPI.GetUserData({}, async (udRes)=>{
    try{
      const data = udRes.data.Data || {};
      const secret = data.two_factor_secret && data.two_factor_secret.Value;
      if(!secret){ setStatus("2FA not configured for this account","red"); return; }
      const ok = await verifyTOTP(secret, code);
      if(ok){
        // proceed to finalize
        sessionStorage.removeItem("PLAYFAB_PENDING_LOGIN");
        await finalizeSessionAfter2FAVerified(res);
      } else {
        setStatus("Invalid 2FA code","red");
      }
    }catch(e){ console.error(e); setStatus("Error verifying 2FA","red"); }
  }, (err)=>{ console.error(err); setStatus("Failed to read 2FA settings","red"); });
});

/* Cancel 2FA (abort pending login) */
cancel2faBtn.addEventListener("click", ()=>{
  sessionStorage.removeItem("PLAYFAB_PENDING_LOGIN");
  twofaBox.style.display = "none";
  setStatus("Login cancelled","yellow");
  twofaInput.value = "";
});

/* ============================
   Inventory functions (unchanged)
   ============================ */
function fetchInventory(){
  const pfid = localStorage.getItem("PLAYFAB_PLAYFABID");
  const ticket = localStorage.getItem("PLAYFAB_SESSIONTICKET");
  if(!pfid || !ticket){ inventoryGrid.innerHTML = "<p>Login to view inventory.</p>"; return; }
  PlayFab._internalSettings.sessionTicket = ticket;
  inventoryGrid.innerHTML = "Loading...";
  PlayFabClientAPI.GetUserInventory({}, res=>{
    const items = res.data.Inventory || [];
    inventoryGrid.innerHTML = "";
    if(!items.length){ inventoryGrid.innerHTML = "<p>No items</p>"; return; }
    items.forEach(i=>{
      const html = `<div class="tile">
        <img src="images/wsx.png" alt="">
        <h3>${i.DisplayName || i.ItemId}</h3>
        <p>Uses: ${i.RemainingUses ?? "—"}</p>
      </div>`;
      inventoryGrid.insertAdjacentHTML("beforeend", html);
    });
  }, err=>{
    console.error(err);
    inventoryGrid.innerHTML = "<p>Error loading inventory</p>";
  });
}
refreshBtn.addEventListener("click", fetchInventory);

/* ============================
   Profile customizer saves to PlayFab (if logged in)
   - UpdateUserTitleDisplayName for display name
   - UpdateUserData for avatar URL (stored under avatarUrl)
   ============================ */
saveProfile.addEventListener("click", ()=>{
  const name = customUsername.value.trim() || "User";
  const avatar = customAvatarURL.value.trim() || "images/default_avatar.png";
  // update local UI & storage
  navbarName.textContent = name;
  navbarPFP.src = avatar;
  customAvatar.src = avatar;
  localStorage.setItem("CUSTOM_USERNAME", name);
  localStorage.setItem("CUSTOM_AVATAR", avatar);
  setStatus("Profile updated locally","#ffd400");
});

/* Save both DisplayName and avatar to PlayFab.
   We call UpdateUserTitleDisplayName first, then UpdateUserData for avatarUrl.
   On success we update localStorage and UI.
*/
savePlayfabBtn.addEventListener("click", ()=>{
  const pfid = localStorage.getItem("PLAYFAB_PLAYFABID");
  const ticket = localStorage.getItem("PLAYFAB_SESSIONTICKET");
  if(!pfid || !ticket){ alert("You must be logged in to save to PlayFab"); return; }
  PlayFab._internalSettings.sessionTicket = ticket;
  const name = customUsername.value.trim();
  const avatar = customAvatarURL.value.trim();

  // If both are empty, nothing to save
  if(!name && !avatar){ setStatus("Nothing to save","#ffd400"); return; }

  // Save display name first (if provided)
  const saveAvatar = ()=>{
    if(avatar){
      PlayFabClientAPI.UpdateUserData({Data:{avatarUrl: avatar}}, res=>{
        console.log("Avatar saved",res);
        // store locally and update UI
        localStorage.setItem("CUSTOM_AVATAR", avatar);
        navbarPFP.src = avatar;
        customAvatar.src = avatar;
        setStatus("Avatar saved to PlayFab","#ffd400");
      }, err=>{
        console.error(err);
        setStatus("Failed to save avatar","#ff4d4d");
      });
    }
  };

  if(name){
    PlayFabClientAPI.UpdateUserTitleDisplayName({DisplayName:name}, res=>{
      console.log("DisplayName updated",res);
      localStorage.setItem("CUSTOM_USERNAME", name);
      navbarName.textContent = name;
      customUsername.value = name;
      setStatus("Display name saved to PlayFab","#ffd400");
      // then save avatar
      saveAvatar();
    }, err=>{
      console.error(err);
      setStatus("Failed to save display name","#ff4d4d");
    });
  } else {
    // no name to save, just save avatar
    saveAvatar();
  }
});

/* ============================
   Topbar dropdown + misc UI
   ============================ */
profileButton.addEventListener("click", (e)=>{
  e.stopPropagation();
  profileDropdown.style.display = profileDropdown.style.display === "block" ? "none" : "block";
});
document.addEventListener("click",(e)=>{
  if(!profileDropdown.contains(e.target) && !profileButton.contains(e.target)) profileDropdown.style.display = "none";
});
openCustomizer.addEventListener("click", ()=>{
  profileDropdown.style.display = "none";
  profileCustomizer.scrollIntoView({behavior:"smooth",block:"center"});
});
logoutBtn.addEventListener("click", ()=>{
  localStorage.removeItem("PLAYFAB_PLAYFABID");
  localStorage.removeItem("PLAYFAB_SESSIONTICKET");
  localStorage.removeItem("CUSTOM_USERNAME");
  localStorage.removeItem("CUSTOM_AVATAR");
  PlayFab._internalSettings.sessionTicket = null;
  navbarName.textContent = "User";
  navbarPFP.src = "images/default_avatar.png";
  inventoryCard.style.display = "none";
  setStatus("Logged out","#ffd400");
  profileDropdown.style.display = "none";
});

/* update topbar */
function updateTopbarProfile(name, avatar="images/default_avatar.png"){
  navbarName.textContent = name;
  navbarPFP.src = avatar;
}

/* auto-load saved profile / session but keep login/customizer visible */
(function(){
  const pfid = localStorage.getItem("PLAYFAB_PLAYFABID");
  const customName = localStorage.getItem("CUSTOM_USERNAME");
  const customAvatar = localStorage.getItem("CUSTOM_AVATAR");
  if(customName) navbarName.textContent = customName;
  if(customAvatar) navbarPFP.src = customAvatar;
  if(pfid){
    PlayFab._internalSettings.sessionTicket = localStorage.getItem("PLAYFAB_SESSIONTICKET");
    inventoryCard.style.display = "block";
    // Fetch remote PlayFab user data to sync username/avatar if available
    PlayFabClientAPI.GetUserData({}, (udRes)=>{
      try{
        const data = udRes.data.Data || {};
        if(data.avatarUrl && data.avatarUrl.Value){
          localStorage.setItem("CUSTOM_AVATAR", data.avatarUrl.Value);
          navbarPFP.src = data.avatarUrl.Value;
          customAvatar.src = data.avatarUrl.Value;
          customAvatarURL.value = data.avatarUrl.Value;
        }
      }catch(e){ console.warn("GetUserData (on load) error", e); }
    }, (err)=>{
      console.warn("GetUserData (on load) failed", err);
    });

    // also attempt to get server-side display name via GetPlayerProfile (optional)
    PlayFabClientAPI.GetPlayerProfile({PlayFabId: pfid, ProfileConstraints:{ShowDisplayName:true}}, (profRes)=>{
      try{
        const dn = profRes.data.PlayerProfile && profRes.data.PlayerProfile.DisplayName;
        if(dn){
          localStorage.setItem("CUSTOM_USERNAME", dn);
          navbarName.textContent = dn;
          customUsername.value = dn;
        } else if(customName){
          navbarName.textContent = customName;
        }
      }catch(e){ console.warn("GetPlayerProfile error", e); }
    },(err)=>{ /* ignore */ });

    PlayFab._internalSettings.sessionTicket = localStorage.getItem("PLAYFAB_SESSIONTICKET");
    fetchInventory();
    setStatus("Cached session: " + pfid, "#ffd400");
  }
  refreshTOTPStatus();
})();
</script>
</body>
</html>